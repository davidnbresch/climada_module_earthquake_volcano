function eq_data_calculated_damage = validate_eq_damage(eq_data, check_plot)
% Calculate damages of single earthquakes (and compare to historic data)
% MODULE:
% eq_global
% NAME:
%   validate_eq_damage
% PURPOSE:
%   Calculate the damages (in USD) of individual events, e.g., to compare
%   them to historic damage data for validation purposes 
% CALLING SEQUENCE:
%   eq_data_calculated_damage = validate_eq_damage(eq_data)
% EXAMPLE:
%   eq_data_calculated_damage = validate_eq_damage
% OPTIONAL INPUTS:
%   eq_data, a structure generated by reading a catalog of historic
%   earthquakes (see eq_isc_gem_read) or by 'boosting' historic earthquakes
%   to a probabilistic event set (see eq_global_probabilistic). 
%   eq_data contains the following fields:
%       yyyy(line_i)    : year
%       mm(line_i)      : month
%       dd(line_i)      : day
%       hr(line_i)      : origin hour
%       min(line_i)     : origin min
%       sec(line_i)     : origin sec
%       glat(line_i)    : geographic latitude
%       glon(line_i)    : geographic longitude
%       dep(line_i)     : focal depth
%       mag(line_i)     : magnitude
%       country(line_i) : country
%
%   Alternatively, eq_data can also be a filename of a saved eq_data
%   structure, or the filename of an excel file to read the earthquake data
%   from (e.g., the file signieq_table_for_validation.xls in 
%   eq_global/data/epicenters). 
%   In the latter case, the excel sheet needs to have the following
%   fields:
%       YEAR        : year when the earthquake happened
%       MONTH       : month
%       DAY         : day
%       HOUR        : hour
%       MINUTE      : minute
%       SECOND      : second
%       FOCAL_DEPTH : hypocenter depth (km)   
%       MAGNITUDE   : Richter magnitude of the earthquake
%       COUNTRY     : country 
%       LATITUDE    : geographic latitude
%       LONGITUDE   : geographic longitude
%       DAMAGE_DOLLARS (optional): damage data in USD (historic estimates)
%
%   If eq_data is not given, a dialog box opens to prompt for it.
%
%   check_plot: show a plot of the calculated damages (=1), or not
%   (=0, default). If eq_data contains estimated damage values, these data are 
%   plotted as well to allow for comparison and the mean ratio of
%   calculated to estimated damage is displayed.
% 
% OUTPUTS:
%   eq_data_calculated_damage: eq_data with an additional field  
%   'calculated damage' containing the calculated damages (in USD)
%   of the earthquakes
%
% COMMENT:
% Generating the entities and centroids via climada_create_GDP_entity can
% be pretty time consuming for large countries. If the country-specific 
% entities and centroids are already available as .mat files, the code will
% skip that step and load them directly from those .mat files instead. In
% order for this to work, the entity files need to be placed
% in the /data/entities directory of the climada-master module, and named 
% in the following way:
% ISO3_countryname_centroids.mat (e.g. ITA_Italy_centroids.mat),
% and the centroids need to be placed in the /data/system directory of the
% climada-master module, and named in the following way:
% ISO3_countryname_entity.mat (e.g. ITA_Italy_entity.mat)
% 
% CAUTIONARY NOTE:
% This code was only produced for testing purposes and has not been
% optimized for general applications - it might therefore need some
% adjustment to work properly in different environments.
%
% MODIFICATION HISTORY:
% Melanie Bieli, melanie.bieli@bluewin.ch, 20141212, initial
% Melanie Bieli, melanie.bieli@bluewin.ch, 20150123, minor changes
% David N. Bresch, david.bresch@gmail.com, 20150819, climada_global.centroids_dir introduced
%-

% init global variables
global climada_global
if ~climada_init_vars,return;end

% initialize output
eq_data_calculated_damage = struct([]); 

% check argument and set default values
if ~exist('eq_data','var'),eq_data=[];end
if ~exist('check_plot','var'),check_plot=0;end

% set directories
entities_data_dir = [climada_global.data_dir filesep 'entities'];
eq_data_dir=[fileparts(fileparts(mfilename('fullpath'))) filesep 'data' filesep 'epicenters'];

% prompt for eq_data if not given {'*.mat';'*.xls*'}
if isempty(eq_data) % local GUI
    [filename, pathname]=uigetfile(fullfile(eq_data_dir,'*.xls;*.xlsx;*.mat'),'Select epicenter data (either a .mat file or an excel file)');
    if isequal(filename,0) || isequal(pathname,0)
        return; % cancel
    else
        eq_data_file=fullfile(pathname,filename);
        [~, ~, ext] = fileparts(eq_data_file);
    end
end

% Load or read the data, depending on the type of file selected (.mat or
% excel)
if strcmp(ext,'.mat')
    % load the selected .mat file    
    load(eq_data_file);
    vars = whos('-file', eq_data_file);
    if ~strcmp(vars.name,'eq_data')
        eq_data = eval(vars.name);
        clear(vars.name);
    end
elseif strcmp(ext(1:4),'.xls')
    % read the selected .xls or .xlsx file
    eq_data_raw = climada_xlsread('no',eq_data_file,1);
    
    eq_data.yyyy=eq_data_raw.YEAR;
    eq_data.mm=eq_data_raw.MONTH;
    eq_data.dd=eq_data_raw.DAY;
    eq_data.hr=eq_data_raw.HOUR;
    eq_data.min=eq_data_raw.MINUTE;
    eq_data.sec=eq_data_raw.SECOND;
    eq_data.glat=eq_data_raw.LATITUDE; % geographic latitude
    eq_data.glon=eq_data_raw.LONGITUDE; % geographic longitude
    eq_data.dep=eq_data_raw.FOCAL_DEPTH; % focal depth
    eq_data.mag=eq_data_raw.MAGNITUDE;
    eq_data.country=eq_data_raw.COUNTRY;
    if isfield(eq_data_raw,'DAMAGE_DOLLARS')
        eq_data.damage_historic = eq_data_raw.DAMAGE_DOLLARS;
    end
    
    % add further information: serial date number, filename etc.
    eq_data.datenum=datenum(eq_data.yyyy,eq_data.mm,eq_data.dd,eq_data.hr,eq_data.min,eq_data.sec);
    eq_data.filename=eq_data_file;
    eq_data.orig_event_flag=eq_data.yyyy*0+1;
    eq_data.n_epicenters_orig=length(eq_data.yyyy);
    eq_data.ens_size=0; % to indicate only original events
end

%% Calculate damages of all the earthquakes in eq_data in a loop
% The loop goes from the chosen start_index to the chosen end_index (to
% loop over all the events in eq_data, set start_index to 1 and end_index
% to sum(~isnan(eq_data.yyyy(:))) - not length(eq_data.yyyy), since
% climada_xlsread reads all columns up to the maximum length of all columns
% it finds, and sets remaining empty cells in shorter columns to NaN.
calculated_damage = [];
start_index = 1;
end_index = sum(~isnan(eq_data.yyyy(:)));
for i=start_index:end_index
    % check whether centroids and entity of the respective countries already 
    % exist in eq_data_dir, and if not, generate them using 
    % climada_create_GDP_entity
    [~,country_ISO3] = climada_country_name(eq_data.country(i)); % check name and ISO3
    centroids_string = sprintf('%s_%s_centroids.mat',country_ISO3,char(eq_data.country(i)));
    centroids_file = [climada_global.centroids_dir filesep centroids_string];
    entity_string = sprintf('%s_%s_entity.mat',country_ISO3,char(eq_data.country(i)));
    entity_file = [entities_data_dir filesep entity_string];
    if or(~exist(centroids_file,'file'),~exist(entity_file,'file'));
        % centroids and entity are not available, hence calculate them
        [centroids, entity, ~] = climada_create_GDP_entity(char(eq_data.country(i)), [], 0, 1);
        hazard_file_string = sprintf('single_eq_%d.mat',i');
        hazard_set_file = [climada_global.data_dir filesep 'hazards' filesep hazard_file_string];
        % extract the ith hazard from eq_data 
        single_eq_event = climada_get_single_event(eq_data,i);
        single_hazard = eq_global_hazard_set(single_eq_event,hazard_set_file,centroids);
        % calculate damage
        EDS = climada_EDS_calc(entity,single_hazard);
        calculated_damage(i-(start_index-1)) = EDS.damage(1);
        
        save(centroids_file,'centroids');
        save(entity_file,'entity');
        savefile = [climada_global.data_dir filesep 'results' filesep 'calculated_damage.mat'];
        save(savefile,'calculated_damage'); 
        
        fprintf('Finished earthquake %d\n',i);
  
    else
        % centroids and entity are available and can be loaded 
        load(centroids_file,'centroids');
        load(entity_file,'entity');
        hazard_file_string = sprintf('single_eq_%d.mat',i');
        hazard_set_file = [climada_global.data_dir filesep 'hazards' filesep hazard_file_string];
        % extract the ith hazard from eq_data 
        single_eq_event = climada_get_single_event(eq_data,i);
        single_hazard = eq_global_hazard_set(single_eq_event,hazard_set_file,centroids);
        % calculate damage
        EDS = climada_EDS_calc(entity,single_hazard);
        calculated_damage(i-(start_index-1)) = EDS.damage(1);
        
        savefile = [climada_global.data_dir filesep 'results' filesep 'calculated_damage.mat'];
        save(savefile,'calculated_damage'); 
        
        fprintf('Finished earthquake %d\n',i);
    end
end

%% If historic damage data available, calculate and display root mean 
% squared error and mean error ratio of calculated and estimated historic
% damages
if isfield(eq_data,'damage_historic')
    errors_squared = (calculated_damage - eq_data.damage_historic(start_index:end_index)').^2;    % errors squared
    RMSE = sqrt(mean(errors_squared)); % root mean squared error (RMSE)
    mean_error_ratio = mean(calculated_damage./eq_data.damage_historic(start_index:end_index)');
    fprintf('Root mean squared error (RMSE): %d\n',RMSE);
    fprintf('Mean error ratio: %d\n',mean_error_ratio);
    
    % check whether result changes if we only look at nonzero elements
%     historic = eq_data.damage_historic(start_index:end_index);
%     mean_error_ratio_only_nonzeros = mean(calculated_damage(find(calculated_damage))./historic(find(calculated_damage))');
%     fprintf('Mean error ratio nonzero values: %d\n',mean_error_ratio_only_nonzeros);
end

%% create final output by adding calculated_damage to eq_data
eq_data.damage_calculated = calculated_damage;
eq_data_calculated_damage = eq_data;

%% If requested, plot the calculated and historic damage values
if check_plot == 1
    % set colors for plot
    green_RGB = [0 204 0]/255;
    medium_red_RGB = [225 72 72]/255;
    
    x = start_index:end_index;
    plot(x,calculated_damage/10^6,'square','markersize',5,'Color',green_RGB,'markerfacecolor',green_RGB)
    hold on;
    plot(x, eq_data.damage_historic(start_index:end_index)'/10^6,'square','markersize',5, 'Color',medium_red_RGB,'markerfacecolor',medium_red_RGB);
    axis([start_index,end_index,0,10000]);
    xlabel('earthquake index');
    ylabel('damage (USD million)');
    title('Earthquake damage - historic and calculated')
    legend('calculated damage','historic damage')
    hold off;
    
end


    
